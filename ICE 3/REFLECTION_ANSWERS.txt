ANSWERS
1.Live polling apps like Kahoot, Mentimeter, Google Forms, and StrawPoll offer real-time quizzes, polls, and audience interaction but face risks like bot attacks, vote manipulation, phishing, and privacy breaches. Security matters because it protects the integrity of results, keeps user data private, and maintains trust in the platform. Without strong safeguards, polls can be easily manipulated or misused, leading to unfair outcomes and loss of credibility.
2. SSL/TLS encrypts data between a browser and a server so no one can spy on or change it. HTTPS is just HTTP with this encryption, making it safer than plain HTTP. Web apps need SSL to protect passwords, personal info, and keep data trustworthy. Without it, hackers can steal or alter data and impersonate websites. A real example is Equifax’s 2017 breach, where expired SSL certificates weakened their security and let attackers go unnoticed.
3.JWT (JSON Web Token) is a compact, signed format for securely passing user claims between a client and server. It’s useful because it allows stateless authentication and authorization without keeping sessions on the server. When a user logs in, the server issues a token the client sends with each request, and the server verifies its signature to grant access. Without SSL/TLS, JWTs can be intercepted and reused by attackers. A real-world example is the “alg:none” flaw discovered in some JWT libraries, which let attackers bypass signature checks and gain unauthorized access.
4.NO QUESTIONS
5. NO QUESTIONS 
6. Helmet is an Express middleware that secures your app by setting HTTP headers to protect against common web attacks like XSS, clickjacking, and MIME sniffing. By enabling it, your tech stack benefits from improved security and safer defaults with minimal configuration.
7. RBAC (Role-Based Access Control) lets you give users access based on their role, like admin, manager, or regular user, instead of individually. It’s important because it keeps sensitive parts of an app secure, makes permission management easier, and helps with compliance. Without it, users could access things they shouldn’t, causing data leaks or security breaches — for example, Facebook’s “View As” flaw in 2018 exposed private data.
8.Rate limiting limits how many requests a client can make to prevent abuse. It’s key for login/register to stop brute-force attacks. Per-IP or per-user limits help, and proxies can affect accuracy, so production setups combine both for safety.
9. Linting checks your code for style and common errors, keeping it clean and consistent. Unit tests check small parts of your code to make sure they work correctly. Both are critical to catch bugs early and maintain quality, and they can be automated with tools like ESLint and Jest. In Node.js, you run linting with `npx eslint` and unit tests with `npm test`. Flaky tests can waste time and make it hard to trust your code.
10. Docker lets you package apps with all their dependencies into containers for consistent environments. Docker‑Compose manages multiple containers together, like a database and API. They’re essential because they make development, testing, and deployment predictable and portable. You can automate building and running containers with scripts or CI/CD pipelines. To dockerize a Node.js API, you write a `Dockerfile` and optionally a `docker-compose.yml` to define services.
